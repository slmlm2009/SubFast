"""
CSV Report Parser for Integration Tests

This module provides utilities to parse and validate CSV reports
generated by subfast_rename.py during integration testing.
"""

import csv
from pathlib import Path
from typing import Dict, List, Optional


class ReportEntry:
    """Represents a single entry in the renaming report."""
    
    def __init__(self, extracted_episode: str, original_video: str, original_subtitle: str, new_subtitle: str):
        """Initialize from parsed matched episode line."""
        self.extracted_episode = extracted_episode
        self.original_video = original_video
        self.original_subtitle = original_subtitle
        self.new_video = ''  # Not renamed
        self.new_subtitle = new_subtitle
        self.status = 'renamed'
        self.notes = ''
    
    def __repr__(self):
        return f"ReportEntry(video={self.original_video}, extracted={self.extracted_episode}, status={self.status})"


class CSVReportParser:
    """Parser for subfast renaming CSV reports."""
    
    def __init__(self, csv_path: Path):
        """
        Initialize parser with CSV file path.
        
        Args:
            csv_path: Path to the renaming_report.csv file
        """
        self.csv_path = csv_path
        self.entries: List[ReportEntry] = []
        self._parse()
    
    def _parse(self):
        """Parse the text-based CSV report and load entries from MATCHED EPISODES section."""
        if not self.csv_path.exists():
            raise FileNotFoundError(f"CSV report not found: {self.csv_path}")
        
        import re
        
        with open(self.csv_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find the MATCHED EPISODES section
        # Format: # S01E05 -> Video: [VAR1]-Show.mkv | Subtitle: [VAR1]-Show.srt -> [VAR1]-Show.ar.srt
        pattern = r'# (S\d+E\d+) -> Video: (.+?) \| Subtitle: (.+?) -> (.+?)$'
        
        for line in content.splitlines():
            match = re.match(pattern, line.strip())
            if match:
                extracted_episode = match.group(1)
                original_video = match.group(2)
                original_subtitle = match.group(3)
                new_subtitle = match.group(4)
                
                self.entries.append(ReportEntry(
                    extracted_episode=extracted_episode,
                    original_video=original_video,
                    original_subtitle=original_subtitle,
                    new_subtitle=new_subtitle
                ))
    
    def find_by_var_tag(self, var_tag: str) -> Optional[ReportEntry]:
        """
        Find entry by VAR tag.
        
        Args:
            var_tag: VAR tag to search for (e.g., "VAR1")
        
        Returns:
            ReportEntry if found, None otherwise
        """
        for entry in self.entries:
            # Check if either video or subtitle contains the VAR tag
            if f"[{var_tag}]" in entry.original_video or f"[{var_tag}]" in entry.original_subtitle:
                return entry
        return None
    
    def find_by_filename(self, filename: str) -> Optional[ReportEntry]:
        """
        Find entry by original filename.
        
        Args:
            filename: Original filename to search for
        
        Returns:
            ReportEntry if found, None otherwise
        """
        for entry in self.entries:
            if filename in entry.original_video or filename in entry.original_subtitle:
                return entry
        return None
    
    def get_all_entries(self) -> List[ReportEntry]:
        """Get all report entries."""
        return self.entries
    
    def get_paired_count(self) -> int:
        """Get count of successfully paired video/subtitle entries."""
        return sum(1 for e in self.entries if e.original_video and e.original_subtitle)
    
    def get_unpaired_count(self) -> int:
        """Get count of unpaired entries."""
        return sum(1 for e in self.entries if not (e.original_video and e.original_subtitle))
    
    def get_success_count(self) -> int:
        """Get count of successful renaming operations."""
        return sum(1 for e in self.entries if 'success' in e.status.lower() or 'renamed' in e.status.lower())
    
    def get_failure_count(self) -> int:
        """Get count of failed renaming operations."""
        return sum(1 for e in self.entries if 'fail' in e.status.lower() or 'error' in e.status.lower())


def extract_var_tag(filename: str) -> Optional[str]:
    """
    Extract VAR tag from filename.
    
    Args:
        filename: Filename potentially containing [VAR#] tag
    
    Returns:
        VAR tag (e.g., "VAR1") or None if not found
    
    Examples:
        >>> extract_var_tag("[VAR1]-Show.mkv")
        'VAR1'
        >>> extract_var_tag("[VAR3]-Series.srt")
        'VAR3'
        >>> extract_var_tag("NoTag.mkv")
        None
    """
    import re
    match = re.search(r'\[(VAR\d+)\]', filename)
    return match.group(1) if match else None
